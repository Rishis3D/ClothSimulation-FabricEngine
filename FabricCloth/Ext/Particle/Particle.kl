require Math;
require Geometry;

interface BaseConstraint;

// Forward declare this as it lives elsewhere in the extension
// http://docs.fabric-engine.com/FabricEngine/1.13.0/HTML/KLProgrammingGuide/types.html#forward-declaration-of-objects-and-interfaces
object SpringConstraint;

operator addForce<<<index>>>(
	io Ref<Cloth> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	addForcePerVertex(index, _cloth, _attributes, _force);
}

operator simulateCloth<<<index>>>(
	io Ref<Cloth> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	Vec3Attribute pos = _attributes.getAttribute("positions", Vec3Attribute);
	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
	vel.values[index] += _force / mass.values[index];
}

// object ConstraintAttribute : Vec3Attribute
// {

// };

/**
 * The Cloth object extends the Points functionality with soft body dynamics simulated using constraints. 
 * Building 
 * 
 * Per vertex data is stored in GeometryAttributes, such as mass and acceleration.
 * 
 * 
 * 
 */
object Cloth : Points
{
	Boolean m_useGPU;

	Boolean m_isActive;
	Vec3 m_gravity;
	
	Float64 m_currentTime;
	Float64 m_previousTime;
	Float64 m_deltaTime;
	Float32 m_fps;

	// SpringConstraint constraints;

	//Per Vertex attributes
	IntegerAttribute m_attribMovable;
	ScalarAttribute m_attribMass;
	Vec3Attribute m_attribPrevPos;
	Vec3Attribute m_attribAcceleration;

	// ConstraintAttribute m_attribConstraint;
	// Vec3Attribute m_attribAccumulatedNormal;
};

/**
 * Constructor initializes the cloth constraints based on the topology of the PolygonMesh.
 * Quad based meshes will work best.
 * 
 * \param _mesh will be used to initialize the constraint setup of the cloth.
 */
function Cloth(in PolygonMesh _mesh)
{
    this.setupAttribs();

    report( "Cloth Init >> " + _mesh.polygonCount() );

    //this.constraints.resize(0);
}

function Cloth.addForce!(in Vec3 _force)
{
	// There is an inherent overhead in a PEX that may make it less efficient than serial calls in the case 
	// that the operator that is called is trivial. Parallel executions best with large workloads. - Fabric Docs
	Size pointCount = this.elementCount();
	Ref<GeometryAttributes> attribs = this.getAttributes();

	if( pointCount < 1000 )
	{
		// Process in serial for small datasets
		for(Index i = 0; i < pointCount; i++)
		{
			addForcePerVertex(i, this, attribs, _force);
		}
	}
	else
	{
		// Instanciate PEX call for large datasets
		addForce<<<pointCount>>>(this, attribs, _force);
	}
}

/// \internal
inline private addForcePerVertex(
	in Index _index,
	io Ref<Cloth> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
	vel.values[_index] += _force / mass.values[_index];
}


function Cloth.setupAttribs!()
{
	Ref<GeometryAttributes> attributes = this.getAttributes();
	// if (GPU){
    // 	attributes.convertToSVM();
    // }

    this.m_attribMovable			= attributes.getOrCreateIntegerAttribute("movable");
    this.m_attribMass 				= attributes.getOrCreateScalarAttribute("mass");
    this.m_attribPrevPos 			= attributes.getOrCreateVec3Attribute("prevpos");
    this.m_attribAcceleration 		= attributes.getOrCreateVec3Attribute("accel");

    // this.m_attribConstraint = ConstraintAttribute();
    // this.m_attribConstraint._attachToContainer("constraintTest", attributes);
    // this.m_attribAccumulatedNormal 	= attributes.getOrCreateVec3Attribute("accumnrm");
}

function Cloth.stepSimulation!()
{   
	// Solve constraints
    
	// Step particles
	
	// Solve collisions
}

operator entry()
{
	PolygonMesh mesh = PolygonMesh();
	mesh.addPlane(Xfo(), 1, 1, 10, 10);
	Cloth sim(mesh);

	report("Success");
}