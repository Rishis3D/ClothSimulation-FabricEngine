require Math;
require Geometry;



interface BaseForce
{
	initialise!();
	apply!(io Ref<GeometryAttributes> attributes);
};

interface BaseIntegrator
{
	initialise!();
	apply!(io Ref<GeometryAttributes> attributes);
};

/**
 * Interface for all constraints
 * 
 * \dfgPresetOmit
 */
interface BaseConstraint
{
	/// 
	/// \internal
	/// Grid is hardcoded now, so all the solvers need to have rows/columns passed in
	/// Once I've sorted out proper constraint calculations I'll have to pass something elese in
	solve!(io Ref<GeometryAttributes> attrs, UInt32 _rows, UInt32 _cols);
};


object VerletIntergrator : BaseIntegrator
{
	Float32 rate;
};

function VerletIntergrator()
{
	this.initialise();
}

function VerletIntergrator.initialise!()
{
	this.rate = 0.99; // Apply damping to the velocity
}

function VerletIntergrator.apply!(io Ref<GeometryAttributes> attributes)
{
	Ref<Vec3Attribute> positions = attributes.getPositions();
	Ref<Vec3Attribute> velocities = attributes.getOrCreateVec3Attribute('velocities');
	integrate<<<positions.values.size()>>>(	positions.values,
						velocities.values,
						this.rate
						);
	positions.incrementVersion();
	velocities.incrementVersion();
}

operator integrate<<<index>>>(
  io Vec3 positions[],
  io Vec3 velocities[],
  Float32 rate
  )
{
  positions[index] += rate * velocities[index];
  velocities[index] *= 0.99;
}


/**
 * The Cloth object extends the Points functionality with soft body dynamics simulated using constraints. 
 * Building 
 * 
 * Per vertex data is stored in GeometryAttributes, such as mass and acceleration.
 * 
 * 
 * 
 */
object ClothSimulation : Points
{
	Ref<PolygonMesh> mesh;

	Boolean isActive;

	Ref<GeometryAttributes> attrs;

	//Per Vertex _attributes
	IntegerAttribute attribMovable;
	ScalarAttribute attribMass;
	Vec3Attribute attribPrevPos;
	Vec3Attribute attribAcceleration;

	// Force stack
	BaseForce forceStack[];

	// Constraint stack
	BaseConstraint constraintStack[];

	BaseIntegrator integrator;

	// Grid info
	UInt32 rows;
	UInt32 cols;
};

/**
 * Constructor initializes the cloth constraints based on the topology of the PolygonMesh.
 * Quad based meshes will work best.
 * 
 * \param _mesh will be used to initialize the constraint setup of the cloth.
 */
function ClothSimulation(in PolygonMesh _mesh, BaseForce _forceStack[], BaseConstraint _constraintStack[], BaseIntegrator _integrator, UInt32 _rows, UInt32 _cols)
{
	report("Initialising cloth sim");

	this.mesh = _mesh;
	this.attrs = this.mesh.attributes;//getAttributes();

	this.forceStack = _forceStack;
	this.integrator = _integrator;
	this.constraintStack = _constraintStack;

	if( this.integrator == null ) {
		this.integrator = VerletIntergrator();	
	}

	if(_rows < 2 || _cols < 2)
	{
		throw("Rows or columns are invalid");
	}

	Count adjRows = _rows;
	Count adjCols = _cols;
	if (adjRows < 1)  adjRows = 1;
	if (adjCols < 1)  adjCols = 1;

	this.rows = _rows;
	this.cols = _cols;

	report( this.attrs.size() );
  
	// Initialise attributes
	Vec3Attribute velocities = this.attrs.getOrCreateVec3Attribute('velocities');
	IntegerAttribute movable = this.attrs.getOrCreateIntegerAttribute('movable');

	report(velocities.size());
	
	// Pin the cloth at these points for testing
	// for (Index row = 0; _rows <= adjRows; ++row)
	// {
	// 	movable.values[_rows * (adjCols + 1)] = true;
	// }
	
	for(Index i = 0; i < 40; i++)
	{
		movable.values[i] = true;
	}

	report( "Cloth Init >> " + _mesh.polygonCount() );

	//this.setupAttribs();
	//this.constraints.resize(0);
	// 
	report("Initialising cloth sim complete");
}

function ClothSimulation.addForce!(in Vec3 _force)
{
	// There is an inherent overhead in a PEX that may make it less efficient than serial calls in the case 
	// that the operator that is called is trivial. Parallel executions best with large workloads. - Fabric Docs
	Size pointCount = this.elementCount();

	if( pointCount < 1000 )
	{
		// Process in serial for small datasets
		for(Index i = 0; i < pointCount; i++)
		{
			addForcePerVertex(i, this, this.attrs, _force);
		}
	}
	else
	{
		// Instanciate PEX call for large datasets
		addForce<<<pointCount>>>(this, this.attrs, _force);
	}
}

/// \internal
inline private addForcePerVertex(
	in Index _index,
	io Ref<ClothSimulation> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
	vel.values[_index] += _force / mass.values[_index];
}

///
/// \brief      Create necessary attributes
///
/// \internal
function ClothSimulation.setupAttribs!()
{
	// if (GPU){
    // 	attributes.convertToSVM();
    // }

    this.attribMovable			= this.attrs.getOrCreateIntegerAttribute("movable");
    this.attribMass 			= this.attrs.getOrCreateScalarAttribute("mass");
    this.attribPrevPos 			= this.attrs.getOrCreateVec3Attribute("prevpos");
    this.attribAcceleration 		= this.attrs.getOrCreateVec3Attribute("accel");

    // this.m_attribConstraint = ConstraintAttribute();
    // this.m_attribConstraint._attachToContainer("constraintTest", attributes);
    // this.m_attribAccumulatedNormal 	= attributes.getOrCreateVec3Attribute("accumnrm");
}

function ClothSimulation.stepSimulation!()
{   
	// GeometryAttributes attrs = this.mesh.getAttributes();
	report(this.attrs.size());

	//Solve constraints
	for(Index i = 0; i < this.constraintStack.size(); ++i)
	{
		 this.constraintStack[i].solve(this.attrs, this.rows, this.cols);
	}

	//Solve forces
	for(Index i = 0; i < this.forceStack.size(); ++i)
	{
		 this.forceStack[i].apply(this.attrs);
	}

	// // Integrate
	this.integrator.apply(this.attrs);

	Vec3 pos[] = this.attrs.getPositions().values;
	report( pos[5] );
	
	report("Stepping");
}

Vec3[] ClothSimulation.getAllPoints()
{
	Vec3Attribute pos = this.attrs.getAttribute("positions", Vec3Attribute);
	return pos.values;
}

PolygonMesh ClothSimulation.getMesh()
{
	return this.mesh;
}

operator addForce<<<index>>>(
	io Ref<ClothSimulation> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	addForcePerVertex(index, _cloth, _attributes, _force);
}

operator simulateCloth<<<index>>>(
	io Ref<ClothSimulation> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	Vec3Attribute pos = _attributes.getAttribute("positions", Vec3Attribute);
	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
	vel.values[index] += _force / mass.values[index];
}