require Math;
require Geometry;


/// \internal
interface BaseForce
{
	initialise!();
	apply!(io GeometryAttributes attributes);
};

/// \internal
interface BaseIntegrator
{
	initialise!();
	apply!(io GeometryAttributes attributes);
};

/**
 * Interface for all constraints
 * 
 * \dfgPresetOmit
 */
interface BaseConstraint
{
	/// 
	/// \internal
	/// Grid is hardcoded now, so all the solvers need to have rows/columns passed in
	/// Once I've sorted out proper constraint calculations I'll have to pass something elese in
	solve!(io GeometryAttributes attrs, UInt32 _rows, UInt32 _cols);
};


object VerletIntergrator : BaseIntegrator
{
	Float32 rate;
};

function VerletIntergrator()
{
	this.initialise();
}

function VerletIntergrator.initialise!()
{
	this.rate = 0.99; // Apply damping to the velocity
}

function VerletIntergrator.apply!(io GeometryAttributes attributes)
{
	Ref<Vec3Attribute> positions = attributes.getPositions();
	Ref<Vec3Attribute> velocities = attributes.getOrCreateVec3Attribute('velocities');
	integrate<<<positions.values.size()>>>(	positions.values,
						velocities.values,
						this.rate
						);
	positions.incrementVersion();
	velocities.incrementVersion();
}

operator integrate<<<index>>>(
  io Vec3 positions[],
  io Vec3 velocities[],
  Float32 rate
  )
{
  positions[index] += rate * velocities[index];
  velocities[index] *= 0.99;
}


/**
 * The Cloth object extends the Points functionality with soft body dynamics simulated using constraints. 
 * Building 
 * 
 * Per vertex data is stored in GeometryAttributes, such as mass and acceleration.
 * 
 * 
 * 
 */
object ClothSimulation : Points
{
	PolygonMesh mesh;

	Boolean isActive;

	//Per Vertex _attributes
	IntegerAttribute attribMovable;
	ScalarAttribute attribMass;
	Vec3Attribute attribPrevPos;
	Vec3Attribute attribAcceleration;

	// Force stack
	BaseForce forceStack[];

	// Constraint stack
	BaseConstraint constraintStack[];

	BaseIntegrator integrator;

	// Grid info
	UInt32 rows;
	UInt32 cols;
};

/**
 * Constructor initializes the cloth constraints based on the topology of the PolygonMesh.
 * Quad based meshes will work best.
 * 
 * \param _mesh will be used to initialize the constraint setup of the cloth.
 */
function ClothSimulation(in PolygonMesh _mesh, BaseForce _forceStack[], BaseConstraint _constraintStack[], BaseIntegrator _integrator, UInt32 _rows, UInt32 _cols)
{
	this.setupAttribs();

	this.forceStack = _forceStack;
	this.integrator = _integrator;
	this.constraintStack = _constraintStack;

	this.mesh = _mesh;

	Count adjRows = _rows;
	Count adjCols = _cols;
	if (adjRows < 1)  adjRows = 1;
	if (adjCols < 1)  adjCols = 1;

	this.rows = _rows;
	this.cols = _cols;
  
	// Initialise attribuets
	GeometryAttributes attrs = _mesh.getAttributes();
	Vec3Attribute velocities = attrs.getOrCreateVec3Attribute('velocities');
	IntegerAttribute movable = attrs.getOrCreateIntegerAttribute('movable');
	
	// Pin the cloth at these points for testing
	for (Index row = 0; _rows <= adjRows; ++row)
	{
		movable.values[_rows * (adjCols + 1)] = true;
	}

	report( "Cloth Init >> " + _mesh.polygonCount() );

	//this.constraints.resize(0);
}

function ClothSimulation.addForce!(in Vec3 _force)
{
	// There is an inherent overhead in a PEX that may make it less efficient than serial calls in the case 
	// that the operator that is called is trivial. Parallel executions best with large workloads. - Fabric Docs
	Size pointCount = this.elementCount();
	Ref<GeometryAttributes> attribs = this.getAttributes();

	if( pointCount < 1000 )
	{
		// Process in serial for small datasets
		for(Index i = 0; i < pointCount; i++)
		{
			addForcePerVertex(i, this, attribs, _force);
		}
	}
	else
	{
		// Instanciate PEX call for large datasets
		addForce<<<pointCount>>>(this, attribs, _force);
	}
}

/// \internal
inline private addForcePerVertex(
	in Index _index,
	io Ref<ClothSimulation> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
	vel.values[_index] += _force / mass.values[_index];
}

///
/// \brief      Create necessary attributes
///
/// \internal
function ClothSimulation.setupAttribs!()
{
	Ref<GeometryAttributes> attributes = this.getAttributes();
	// if (GPU){
    // 	attributes.convertToSVM();
    // }

    this.attribMovable			= attributes.getOrCreateIntegerAttribute("movable");
    this.attribMass 			= attributes.getOrCreateScalarAttribute("mass");
    this.attribPrevPos 			= attributes.getOrCreateVec3Attribute("prevpos");
    this.attribAcceleration 		= attributes.getOrCreateVec3Attribute("accel");

    // this.m_attribConstraint = ConstraintAttribute();
    // this.m_attribConstraint._attachToContainer("constraintTest", attributes);
    // this.m_attribAccumulatedNormal 	= attributes.getOrCreateVec3Attribute("accumnrm");
}

function ClothSimulation.stepSimulation!()
{   
	GeometryAttributes attrs = this.getAttributes();

	// Solve constraints
	for(Index i = 0; i < this.constraintStack.size(); ++i)
	{
		 this.constraintStack[i].solve(attrs, this.rows, this.cols);
	}

	// Solve forces
	// for(Index i = 0; i < this.forceStack.size(); ++i)
	// {
	// 	 this.forceStack[i].apply(attrs);
	// }

	// Integrate
	this.integrator.apply(attrs);
}

Vec3[] ClothSimulation.getAllPoints()
{
	GeometryAttributes attrs = this.getAttributes();
	Vec3Attribute pos = attrs.getAttribute("positions", Vec3Attribute);
	return pos.values;
}

PolygonMesh ClothSimulation.getMesh()
{
	return this.mesh;
}

operator addForce<<<index>>>(
	io Ref<ClothSimulation> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	addForcePerVertex(index, _cloth, _attributes, _force);
}

operator simulateCloth<<<index>>>(
	io Ref<ClothSimulation> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	Vec3Attribute pos = _attributes.getAttribute("positions", Vec3Attribute);
	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
	vel.values[index] += _force / mass.values[index];
}