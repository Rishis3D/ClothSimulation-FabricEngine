/// \version 1.0
/// \file Particle.kl
///
/// \brief The main softbody simulation object, can be configured using a stack of forces and constraints. Integrator can be chosen by plugging that in too.
///
/// \author Tom Minor, NCCA, Bournemouth University
/// \date 09/05/16
///
/// \todo 	A bit haphazard right now, the polygon mesh is stored internally
///			which makes resetting go funky because I'm modifying the original instead of a copy.
///			Also attributes are stored directly in the mesh, would make more sense to store those on an
///			internal copy too.

require Math;
require Geometry;

/**
 * @brief The Cloth object extends the Points functionality with soft body dynamics simulated using constraints. 
 * Building 
 * 
 * Per vertex data is stored in GeometryAttributes, such as mass and acceleration.
 * 
 */
object ClothSimulation : Points
{
	Ref<PolygonMesh> mesh;

	Boolean isActive;

	Ref<GeometryAttributes> attrs;

	//Per Vertex _attributes
	IntegerAttribute attribMovable;
	ScalarAttribute attribMass;
	Vec3Attribute attribPrevPos;
	Vec3Attribute attribAcceleration;

	// Force stack
	BaseForce forceStack[];

	// Constraint stack
	BaseConstraint constraintStack[];

	BaseIntegrator integrator;

	// Grid info
	UInt32 rows;
	UInt32 cols;
};

/**
 * Constructor initializes the cloth constraints based on the topology of the PolygonMesh.
 * Quad based meshes will work best.
 * 
 * \param _mesh will be used to initialize the constraint setup of the cloth.
 * \param _forceStack holds all the forces to be evaluated every simulation step
 * \param _constraintStack holds all the constraints to be evaluated every simulation step
 * \param _integrator is used to evaluate every simulation step
 * \param _rows
 * \param _cols
 */
function ClothSimulation(in PolygonMesh _mesh, BaseForce _forceStack[], BaseConstraint _constraintStack[], BaseIntegrator _integrator, UInt32 _rows, UInt32 _cols)
{
	report("Initialising cloth sim");

	this.mesh = _mesh;
	this.attrs = this.mesh.attributes;//getAttributes();

	this.forceStack = _forceStack;
	this.integrator = _integrator;
	this.constraintStack = _constraintStack;

	if( this.integrator == null ) {
		this.integrator = VerletIntergrator();	
	}

	if(_rows < 2 || _cols < 2)
	{
		throw("Rows or columns are invalid");
	}

	Count adjRows = _rows;
	Count adjCols = _cols;
	if (adjRows < 1)  adjRows = 1;
	if (adjCols < 1)  adjCols = 1;

	this.rows = _rows;
	this.cols = _cols;

	report( this.attrs.size() );
  
	// Initialise attributes
	Vec3Attribute velocities = this.attrs.getOrCreateVec3Attribute('velocities');
	IntegerAttribute movable = this.attrs.getOrCreateIntegerAttribute('movable');

	report(velocities.size());
	
	// Pin the cloth at these points for testing
	// for (Index row = 0; _rows <= adjRows; ++row)
	// {
	// 	movable.values[_rows * (adjCols + 1)] = true;
	// }
	
	for(Index i = 0; i < 40; i++)
	{
		movable.values[i] = true;
	}

	// report( "Cloth Init >> " + _mesh.polygonCount() );

	//this.setupAttribs();
	//this.constraints.resize(0);
	// 
	report("Initialising cloth sim complete");
}

// function ClothSimulation.addForce!(in Vec3 _force)
// {
// 	// There is an inherent overhead in a PEX that may make it less efficient than serial calls in the case 
// 	// that the operator that is called is trivial. Parallel executions best with large workloads. - Fabric Docs
// 	Size pointCount = this.elementCount();

// 	if( pointCount < 1000 )
// 	{
// 		// Process in serial for small datasets
// 		for(Index i = 0; i < pointCount; i++)
// 		{
// 			addForcePerVertex(i, this, this.attrs, _force);
// 		}
// 	}
// 	else
// 	{
// 		// Instanciate PEX call for large datasets
// 		addForce<<<pointCount>>>(this, this.attrs, _force);
// 	}
// }

// /// \internal
// inline private addForcePerVertex(
// 	in Index _index,
// 	io Ref<ClothSimulation> _cloth, 
// 	io Ref<GeometryAttributes> _attributes,
// 	in Vec3 _force
// 	)
// {
// 	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
// 	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
// 	vel.values[_index] += _force / mass.values[_index];
// }

// ///
// /// \brief      Create necessary attributes
// ///
// /// \internal
// function ClothSimulation.setupAttribs!()
// {
// 	// if (GPU){
//     // 	attributes.convertToSVM();
//     // }

//     this.attribMovable			= this.attrs.getOrCreateIntegerAttribute("movable");
//     this.attribMass 			= this.attrs.getOrCreateScalarAttribute("mass");
//     this.attribPrevPos 			= this.attrs.getOrCreateVec3Attribute("prevpos");
//     this.attribAcceleration 		= this.attrs.getOrCreateVec3Attribute("accel");

//     // this.m_attribConstraint = ConstraintAttribute();
//     // this.m_attribConstraint._attachToContainer("constraintTest", attributes);
//     // this.m_attribAccumulatedNormal 	= attributes.getOrCreateVec3Attribute("accumnrm");
// }

/**
 * @brief      Steps the simulation forward in time by evaluating the chosen integrator to calculate particle movement.
 *
 */
function ClothSimulation.stepSimulation!()
{   
	// GeometryAttributes attrs = this.mesh.getAttributes();
	// report(this.attrs.size());

	//Solve constraints
	for(Index i = 0; i < this.constraintStack.size(); ++i)
	{
		 this.constraintStack[i].solve(this.attrs, this.rows, this.cols);
	}

	//Solve forces
	for(Index i = 0; i < this.forceStack.size(); ++i)
	{
		 this.forceStack[i].apply(this.attrs);
	}

	//Integrate
	this.integrator.apply(this.attrs);

	// Vec3 pos[] = this.attrs.getPositions().values;
	// report( pos[5] );
	
	report("Stepping Simulation");
}


Vec3[] ClothSimulation.getAllPoints()
{
	Vec3Attribute pos = this.attrs.getAttribute("positions", Vec3Attribute);
	return pos.values;
}

PolygonMesh ClothSimulation.getMesh()
{
	return this.mesh;
}

// operator addForce<<<index>>>(
// 	io Ref<ClothSimulation> _cloth, 
// 	io Ref<GeometryAttributes> _attributes,
// 	in Vec3 _force
// 	)
// {
// 	addForcePerVertex(index, _cloth, _attributes, _force);
// }

// operator simulateCloth<<<index>>>(
// 	io Ref<ClothSimulation> _cloth, 
// 	io Ref<GeometryAttributes> _attributes,
// 	in Vec3 _force
// 	)
// {
// 	Vec3Attribute pos = _attributes.getAttribute("positions", Vec3Attribute);
// 	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
// 	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
// 	vel.values[index] += _force / mass.values[index];
// }