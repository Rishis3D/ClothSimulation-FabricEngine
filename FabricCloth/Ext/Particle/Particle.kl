require Math;
require Geometry;

interface BaseConstraint;

// Forward declare this as it lives elsewhere in the extension
// http://docs.fabric-engine.com/FabricEngine/1.13.0/HTML/KLProgrammingGuide/types.html#forward-declaration-of-objects-and-interfaces
object SpringConstraint;

operator addForce<<<index>>>(
	io Ref<Cloth> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	addForcePerVertex(index, _cloth, _attributes, _force);
}

operator simulateCloth<<<index>>>(
	io Ref<Cloth> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	Vec3Attribute pos = _attributes.getAttribute("positions", Vec3Attribute);
	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
	vel.values[index] += _force / mass.values[index];
}

// object ConstraintAttribute : Vec3Attribute
// {

// };

// Inherit from points 
object Cloth : Points
{
	Boolean m_useGPU;

	Boolean m_isActive;
	Vec3 m_gravity;
	Float32 m_fps;

	// SpringConstraint constraints;

	//Per Vertex attributes
	IntegerAttribute m_attribMovable;
	ScalarAttribute m_attribMass;
	Vec3Attribute m_attribPrevPos;
	Vec3Attribute m_attribAcceleration;

	// ConstraintAttribute m_attribConstraint;
	// Vec3Attribute m_attribAccumulatedNormal;
};

function Cloth.ctor!()
{
    this.setupAttribs();

    // this.constraints.resize(0);
}

function Cloth.addForce!(in Vec3 _force)
{
	// There is an inherent overhead in a PEX that may make it less efficient than serial calls in the case 
	// that the operator that is called is trivial. Parallel executions best with large workloads. - Fabric Docs
	Size pointCount = this.elementCount();
	Ref<GeometryAttributes> attribs = this.getAttributes();

	if( pointCount < 1000 )
	{
		// Process in serial for small datasets
		for(Index i = 0; i < pointCount; i++)
		{
			addForcePerVertex(i, this, attribs, _force);
		}
	}
	else
	{
		// Instanciate PEX call for large datasets
		addForce<<<pointCount>>>(this, attribs, _force);
	}
}

/// \internal
inline private addForcePerVertex(
	in Index _index,
	io Ref<Cloth> _cloth, 
	io Ref<GeometryAttributes> _attributes,
	in Vec3 _force
	)
{
	ScalarAttribute mass = _attributes.getAttribute("mass", ScalarAttribute);
	Vec3Attribute vel = _attributes.getAttribute("accel", Vec3Attribute);
	vel.values[_index] += _force / mass.values[_index];
}


function Cloth.setupAttribs!()
{
	Ref<GeometryAttributes> attributes = this.getAttributes();
	// if (GPU){
    // 	attributes.convertToSVM();
    // }

    this.m_attribMovable			= attributes.getOrCreateIntegerAttribute("movable");
    this.m_attribMass 				= attributes.getOrCreateScalarAttribute("mass");
    this.m_attribPrevPos 			= attributes.getOrCreateVec3Attribute("prevpos");
    this.m_attribAcceleration 		= attributes.getOrCreateVec3Attribute("accel");

    // this.m_attribConstraint = ConstraintAttribute();
    // this.m_attribConstraint._attachToContainer("constraintTest", attributes);
    // this.m_attribAccumulatedNormal 	= attributes.getOrCreateVec3Attribute("accumnrm");
}

function Cloth.step!()
{   
	Vec3 a = Vec3(1,1,1);
    Vec3 b = Vec3(1,0,1);
    
	// for(Index i = 0; i < this.constraints.size(); i++)
	// {
	// 	this.constraints[i].solve(a, b);
	// }
}