require Math;
require Geometry;


///
/// \brief Implements Hookes law to simulate a spring between 2 points
///
/// \dfgPresetFolder Constraints
///
object SpringConstraint : BaseConstraint
{
	Float32 s;
};

///
/// \brief SpringConstraints default ctor
/// \dfgPresetFolder Constraints
///
function SpringConstraint()
{
	this.s = 0.5;
}

///
/// \brief SpringConstraints ctor
/// \dfgPresetFolder Constraints
///
function SpringConstraint(Float32 _s)
{
	this.s = _s;
}

/// \internal
function SpringConstraint.solve!(io Ref<GeometryAttributes> attrs, UInt32 _rows, UInt32 _cols)
{
	// adjust the amount of rows and columns.
	Count adjRows = _rows;
	Count adjCols = _cols;
	if (adjRows < 1)  adjRows = 1;
	if (adjCols < 1)  adjCols = 1;
	Scalar width  = adjCols;
	Scalar height = adjRows;
	Float32 colWidth  = width  / adjCols;
	Float32 rowHeight = height / adjRows;

	Ref<Vec3Attribute> positions = attrs.getPositions();
	Ref<Vec3Attribute> velocities = attrs.getOrCreateVec3Attribute('velocities');
	Ref<IntegerAttribute> movable = attrs.getOrCreateIntegerAttribute('movable');
	satisfyConstraints<<<positions.values.size()>>>(
					positions.values,
					velocities.values,
					movable.values,
					adjCols,
					adjRows,
					colWidth * colWidth,
					rowHeight * rowHeight,
					this.s
					);
	velocities.incrementVersion();
}

operator satisfyConstraints<<<index>>>(
  Vec3 positions[],
  io Vec3 velocities[],
  Integer movable[],
  // hard coded grid shape for now, modified this from a canvas sample
  UInt32 cols,
  UInt32 rows,
  Float32 colWidthSq,
  Float32 rowHeightSq,
  Float32 s
  )
{
	UInt32 row = index / (cols + 1);
	UInt32 col = index % (cols + 1);

	if ( !movable[index] )
	{
		if ( row > 0 )
		{
			Vec3 delta = positions[(row - 1) * (cols + 1) + col] - positions[index];
			Float32 deltaLenSq = delta.lengthSquared();
			Float32 diff = (deltaLenSq - rowHeightSq) / (rowHeightSq + deltaLenSq) * s;
			velocities[index] += delta * diff;
		}

		if ( row < rows )
		{
			Vec3 delta = positions[(row + 1) * (cols + 1) + col] - positions[index];
			Float32 deltaLenSq = delta.lengthSquared();
			Float32 diff = (deltaLenSq - rowHeightSq) / (rowHeightSq + deltaLenSq) * s;
			velocities[index] += delta * diff;
		}

		if ( col > 0 )
		{
			Vec3 delta = positions[row * (cols + 1) + col - 1] - positions[index];
			Float32 deltaLenSq = delta.lengthSquared();
			Float32 diff = (deltaLenSq - colWidthSq) / (colWidthSq + deltaLenSq) * s;
			velocities[index] += delta * diff;
		}

		if ( col < cols )
		{
			Vec3 delta = positions[row * (cols + 1) + col + 1] - positions[index];
			Float32 deltaLenSq = delta.lengthSquared();
			Float32 diff = (deltaLenSq - colWidthSq) / (colWidthSq + deltaLenSq) * s;
			velocities[index] += delta * diff;
		}
	}
}